<span lang="zh">
  <div class="expression">{{Expression}}</div>

  <div class="pinyin">{{Reading}}</div>

  <div class="content-container">
    <div class="sentence-container">
      <div class="sentence">
        <span class="hanzi-version">
          {{Sentence}}
        </span>
        <span class="ruby-version">
          {{#SentenceReading}}
            {{furigana:SentenceReading}}
          {{/SentenceReading}}
          {{^SentenceReading}}
            {{Sentence}}
          {{/SentenceReading}}
        </span>
      </div>
    </div>

    {{#Media}}
    <div class="image-container">
      {{Media}}
    </div>
    {{/Media}}
  </div>

  {{#Notes}}
  <div class="notes-container">
    <div class="notes-header">附注</div>
    <div class="notes-content">{{Notes}}</div>
  </div>
  {{/Notes}}

  <div class="glossary-container">
    <div class="glossary-header"">
      <span>意思</span>
      <span class=" toggle-icon">▼
</span>
</div>
<div id="glossary" class="glossary-content collapsed">{{Glossary}}</div>
</div>

<div class="audio-controls-container">
  {{#Audio}}
  <div class="audio-button-container">
    <div class="audio-button">
      {{Audio}}
    </div>
    <div class="audio-label">字词发音</div>
  </div>
  {{/Audio}}

  {{#CantoAudio}}
  <div class="audio-button-container">
    <div class="audio-button">
      {{CantoAudio}}
    </div>
    <div class="audio-label">粤语发音</div>
  </div>
  {{/CantoAudio}}

  {{#SentenceAudio}}
  <div class="audio-button-container">
    <div class="audio-button">
      {{SentenceAudio}}
    </div>
    <div class="audio-label">例句发音</div>
  </div>
  {{/SentenceAudio}}
</div>

<div class="source-footer">
  {{#Source}}<div class="source-item">{{Source}}</div>{{/Source}}
  {{#DocumentTitle}}
  <div class="source-item">
    {{#URL}}<a href="{{URL}}" target="_blank">{{DocumentTitle}}</a>{{/URL}}
    {{^URL}}{{DocumentTitle}}{{/URL}}
  </div>
  {{/DocumentTitle}}
  {{^DocumentTitle}}
  {{#URL}}<div class="source-item"><a href="{{URL}}" target="_blank">{{URL}}</a></div>{{/URL}}
  {{/DocumentTitle}}
</div>

<!-- Lightbox for image -->
<div id="lightbox" class="lightbox" onclick="hideLightbox()">
  <span class="close-button">&times;</span>
  <img class="lightbox-content" id="lightbox-img">
</div>
</span>

<script>
  function toggleGlossary() {
    const glossary = document.getElementById('glossary');
    const toggleIcon = document.querySelector('.toggle-icon');

    if (glossary.classList.contains('collapsed')) {
      glossary.classList.remove('collapsed');
      toggleIcon.textContent = '▲';
    } else {
      glossary.classList.add('collapsed');
      toggleIcon.textContent = '▼';
    }
  }

  function showLightbox(src) {
    const lightbox = document.getElementById('lightbox');
    const lightboxImg = document.getElementById('lightbox-img');
    lightboxImg.src = src;
    lightbox.style.display = 'flex';
  }

  function hideLightbox() {
    document.getElementById('lightbox').style.display = 'none';
  }

  // Helper function for legacy copy command
  function legacyCopy(text) {
    const textArea = document.createElement("textarea");
    textArea.value = text;

    // Avoid scrolling to bottom
    textArea.style.top = "0";
    textArea.style.left = "0";
    textArea.style.position = "fixed";

    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();

    let success = false;
    try {
      success = document.execCommand('copy');
      if (success) {
        alert('Expression copied to clipboard! (Legacy method)');
      } else {
         console.error('Legacy copy command failed.');
         alert('Failed to copy expression using legacy method.');
      }
    } catch (err) {
      console.error('Error using legacy copy command: ', err);
      alert('Error copying expression using legacy method.');
    }

    document.body.removeChild(textArea);
    return success;
  }


  // Set up glossary toggle
  (() => {
    const glossary = document.querySelector('.glossary-container');
    if (glossary) {
      glossary.addEventListener('click', toggleGlossary);
    }
  })();

  // Set up click to copy for expression
  (() => {
    const expressionDiv = document.querySelector('.expression');
    if (expressionDiv) {
      expressionDiv.addEventListener('click', () => {
        const expression = `{{Expression}}`;
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(expression).then(() => {
          }).catch(err => {
            console.error('Clipboard API error: ', err);
            // Fallback to legacy method if Clipboard API fails
            console.log('Trying legacy copy method...');
            legacyCopy(expression);
          });
        } else {
           // Fallback if Clipboard API is not available at all
           console.log('Clipboard API not available, trying legacy copy method...');
           legacyCopy(expression);
        }
      });
    }
  })();

  // Set up lightbox for images
  (() => {
    const images = document.querySelectorAll('.image-container img');
    images.forEach(img => {
      img.addEventListener('click', () => {
        showLightbox(img.src);
      });
    });
  })();

  // Fix SVG styling in audio buttons
  (() => {
    document.querySelectorAll('.audio-button svg').forEach(svg => {
      svg.style.width = '30px';
      svg.style.height = '30px';

      const circle = svg.querySelector('circle');
      if (circle) circle.setAttribute('fill', 'transparent');

      const path = svg.querySelector('path');
      if (path) path.setAttribute('fill', 'white');
    });
  })();

  // Show both simplified/traditional characters
  (() => {
    /**
     * Get simplified and traditional characters from CCCEDICT.
     * @returns { { simplified: string, traditional: string } | null}
     */
    function getSimpTradFromCCCEDICT() {
      // <div data-sc-cccedict="headword">【純粹・纯粹】</div>
      const headword = document.querySelector('[data-sc-cccedict]');
      if (headword) {
        const text = headword.textContent;
        const match = text.match(/【(.+)・(.+)】/);
        if (match) {
          const traditional = match[1].trim();
          const simplified = match[2].trim();
          return { simplified, traditional };
        }
      }
      return null;
    }

    const cccedict = getSimpTradFromCCCEDICT();
    if (cccedict) {
      const { simplified, traditional } = cccedict;
      const expressionDiv = document.querySelector('.expression');

      const variants = [
        { type: 'traditional', text: traditional },
        { type: 'simplified', text: simplified }
      ];

      if (Math.random() < 0.5) {
        variants.reverse();
      }

      expressionDiv.innerHTML = variants
        .map(v => `<span class="${v.type}">${v.text}</span>`)
        .join('');
    }
  })();

  // Highlight expression inside sentence
  (() => {
    const expression = `{{Expression}}`;
    const sentenceHanzi = document.querySelector('.sentence .hanzi-version');
    const sentenceRuby = document.querySelector('.ruby-version');

    // Helper function to get base text from a <ruby> element
    function getRubyBaseText(rubyElement) {
      let base = '';
      if (!rubyElement) return base;
      for (const node of rubyElement.childNodes) {
        if (node.nodeType === Node.TEXT_NODE) {
          base += node.textContent;
        } else if (node.nodeName.toLowerCase() === 'rt') {
          break; // Stop when we hit the ruby text tag
        }
      }
      return base.trim();
    }

    // Highlight in Hanzi version
    if (expression && sentenceHanzi) {
      try {
        // Escape special characters in expression for regex
        const escapedExpression = expression.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        // Use a capturing group to replace only the expression, keeping surrounding text
        const regex = new RegExp(`(${escapedExpression})`, 'g');
        sentenceHanzi.innerHTML = sentenceHanzi.innerHTML.replace(regex, '<strong>$1</strong>');
      } catch (e) {
        console.error("Error highlighting Hanzi:", e);
      }
    }

    // Highlight in Ruby version
    if (expression && sentenceRuby) {
      try {
        const termSpans = Array.from(sentenceRuby.querySelectorAll('.term')); // Convert NodeList to Array
        if (termSpans.length > 0) {
          let plainText = '';
          const spanInfo = []; // Store { element: Node, html: string, start: number, end: number }

          let currentIndex = 0;
          termSpans.forEach(span => {
            const ruby = span.querySelector('ruby');
            // Use helper to get only the base characters
            const baseText = getRubyBaseText(ruby || span); // Fallback to span if no ruby tag

            if (baseText.length > 0) {
              const termLength = baseText.length;
              // Store original element reference along with other info
              spanInfo.push({ element: span, html: span.outerHTML, start: currentIndex, end: currentIndex + termLength - 1 });
              plainText += baseText;
              currentIndex += termLength;
            }
            // Note: Spans without extractable base text are currently ignored in plainText
            // but their original HTML will be preserved in the reconstruction loop.
          });

          const startIndex = plainText.indexOf(expression);

          if (startIndex !== -1) {
            const endIndex = startIndex + expression.length - 1;
            let newInnerHtml = '';
            let spanInfoIndex = 0; // To track the current span in spanInfo array

            // Iterate through the original child nodes to preserve structure (whitespace, etc.)
            Array.from(sentenceRuby.childNodes).forEach(node => {
              if (node.nodeType === Node.ELEMENT_NODE && node.classList.contains('term') && spanInfoIndex < spanInfo.length && node === spanInfo[spanInfoIndex].element) {
                // This node is one of the .term spans we processed
                const currentSpanData = spanInfo[spanInfoIndex];
                // Check if the term's character range overlaps with the expression's range
                if (currentSpanData.start <= endIndex && currentSpanData.end >= startIndex) {
                  newInnerHtml += `<strong>${currentSpanData.html}</strong>`;
                } else {
                  newInnerHtml += currentSpanData.html;
                }
                spanInfoIndex++; // Move to the next processed span
              } else if (node.nodeType === Node.TEXT_NODE) {
                // Preserve text nodes (whitespace, etc.)
                newInnerHtml += node.textContent;
              } else if (node.nodeType === Node.ELEMENT_NODE) {
                 // Preserve other potential elements (though unlikely based on example)
                 newInnerHtml += node.outerHTML;
              }
              // Ignore comment nodes, etc.
            });

            sentenceRuby.innerHTML = newInnerHtml;
          }
        }
      } catch (e) {
        console.error("Error highlighting Ruby:", e);
      }
    }
  })();
</script>